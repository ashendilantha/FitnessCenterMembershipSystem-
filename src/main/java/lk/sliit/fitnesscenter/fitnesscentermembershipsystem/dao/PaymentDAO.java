//package lk.sliit.fitnesscenter.fitnesscentermembershipsystem.dao;////import lk.sliit.fitnesscenter.fitnesscentermembershipsystem.model.Payment;//import java.util.ArrayList;//import java.util.List;//import java.util.Queue;//import java.util.LinkedList;////public class PaymentDAO {//    private static final List<Payment> payments = new ArrayList<>();//    private static final Queue<Payment> paymentQueue = new LinkedList<>();//    private static int paymentIdCounter = 1;////    // Insertion sort implementation for sorting payments by date//    private void sortPaymentsByDate(List<Payment> list) {//        for (int i = 1; i < list.size(); i++) {//            Payment key = list.get(i);//            int j = i - 1;////            while (j >= 0 && list.get(j).getPaymentDate().isAfter(key.getPaymentDate())) {//                list.set(j + 1, list.get(j));//                j = j - 1;//            }//            list.set(j + 1, key);//        }//    }////    // Create a new payment//    public String createPayment(Payment payment) {//        String newPaymentId = "PAY" + String.format("%04d", paymentIdCounter++);//        payment.setPaymentId(newPaymentId);//        payments.add(payment);//        paymentQueue.add(payment);//        return newPaymentId;//    }////    // Get all payments (sorted by date)//    public List<Payment> getAllPayments() {//        List<Payment> sortedPayments = new ArrayList<>(payments);//        sortPaymentsByDate(sortedPayments);//        return sortedPayments;//    }////    // Get payments by member ID (sorted by date)//    public List<Payment> getPaymentsByMember(String memberId) {//        List<Payment> memberPayments = new ArrayList<>();//        for (Payment payment : payments) {//            if (payment.getMemberId().equals(memberId)) {//                memberPayments.add(payment);//            }//        }//        sortPaymentsByDate(memberPayments);//        return memberPayments;//    }////    // Get payment by ID//    public Payment getPaymentById(String paymentId) {//        for (Payment payment : payments) {//            if (payment.getPaymentId().equals(paymentId)) {//                return payment;//            }//        }//        return null;//    }////    // Update payment//    public boolean updatePayment(Payment updatedPayment) {//        for (int i = 0; i < payments.size(); i++) {//            if (payments.get(i).getPaymentId().equals(updatedPayment.getPaymentId())) {//                payments.set(i, updatedPayment);//                return true;//            }//        }//        return false;//    }////    // Delete payment//    public boolean deletePayment(String paymentId) {//        return payments.removeIf(payment -> payment.getPaymentId().equals(paymentId));//    }////    // Process next payment in queue//    public Payment processNextPayment() {//        return paymentQueue.poll();//    }////    // Get queue size//    public int getQueueSize() {//        return paymentQueue.size();//    }//}package lk.sliit.fitnesscenter.fitnesscentermembershipsystem.dao;import lk.sliit.fitnesscenter.fitnesscentermembershipsystem.model.Payment;import java.io.*;import java.time.LocalDateTime;import java.util.*;import java.util.stream.Collectors;public class PaymentDAO {    private static final String FILE_PATH = System.getProperty("user.home") + "/Hansana/payments.txt";    private static final List<Payment> payments = new ArrayList<>();    private static final Queue<Payment> paymentQueue = new LinkedList<>();    private static int paymentIdCounter = 1;    private final MemberDAO memberDAO = new MemberDAO();    public PaymentDAO() {        loadPaymentsFromFile();    }    private void sortPaymentsByDate(List<Payment> list) {        list.sort(Comparator.comparing(Payment::getPaymentDate));    }    public String createPayment(Payment payment) {        if (payment == null || payment.getMemberId() == null) {            throw new IllegalArgumentException("Invalid payment data");        }        if (memberDAO.getMemberById(payment.getMemberId()) == null) {            throw new IllegalArgumentException("Invalid member ID");        }        String newPaymentId = "PAY" + String.format("%04d", paymentIdCounter++);        payment.setPaymentId(newPaymentId);        payments.add(payment);        paymentQueue.add(payment);        saveToFile(payment);        return newPaymentId;    }    public List<Payment> getAllPayments() {        List<Payment> sortedPayments = new ArrayList<>(payments);        sortPaymentsByDate(sortedPayments);        return sortedPayments;    }    public List<Payment> getPaymentsByMember(String memberId) {        List<Payment> memberPayments = payments.stream()                .filter(payment -> payment.getMemberId().equals(memberId))                .collect(Collectors.toList());        sortPaymentsByDate(memberPayments);        return memberPayments;    }    public Payment getPaymentById(String paymentId) {        return payments.stream()                .filter(payment -> payment.getPaymentId().equals(paymentId))                .findFirst()                .orElse(null);    }    public boolean updatePayment(Payment updatedPayment) {        for (int i = 0; i < payments.size(); i++) {            if (payments.get(i).getPaymentId().equals(updatedPayment.getPaymentId())) {                payments.set(i, updatedPayment);                saveAllPayments();                return true;            }        }        return false;    }    public boolean deletePayment(String paymentId) {        boolean removed = payments.removeIf(payment -> payment.getPaymentId().equals(paymentId));        if (removed) {            saveAllPayments();        }        return removed;    }    public Payment processNextPayment() {        Payment payment = paymentQueue.poll();        if (payment != null) {            saveAllPayments();        }        return payment;    }    public int getQueueSize() {        return paymentQueue.size();    }    private void saveToFile(Payment payment) {        File file = new File(FILE_PATH);        file.getParentFile().mkdirs();        try (BufferedWriter writer = new BufferedWriter(new FileWriter(FILE_PATH, true))) {            writer.write(payment.toString());            writer.newLine();        } catch (IOException e) {            throw new RuntimeException("Failed to save payment", e);        }    }    private void saveAllPayments() {        File file = new File(FILE_PATH);        file.getParentFile().mkdirs();        try (BufferedWriter writer = new BufferedWriter(new FileWriter(FILE_PATH))) {            for (Payment payment : payments) {                writer.write(payment.toString());                writer.newLine();            }        } catch (IOException e) {            throw new RuntimeException("Failed to save payments", e);        }    }    private void loadPaymentsFromFile() {        File file = new File(FILE_PATH);        if (!file.exists()) return;        try (BufferedReader reader = new BufferedReader(new FileReader(FILE_PATH))) {            String line;            while ((line = reader.readLine()) != null) {                if (line.trim().isEmpty()) continue;                String[] data = line.split(",");                if (data.length < 7) {                    System.err.println("Skipping invalid payment: " + line);                    continue;                }                try {                    Payment payment = new Payment(                            data[0], data[1], Double.parseDouble(data[2]),                            LocalDateTime.parse(data[3]), data[4], data[5], data[6]                    );                    payments.add(payment);                    paymentQueue.add(payment);                    int idNum = Integer.parseInt(data[0].replace("PAY", ""));                    if (idNum >= paymentIdCounter) {                        paymentIdCounter = idNum + 1;                    }                } catch (Exception e) {                    System.err.println("Skipping malformed payment: " + line);                }            }        } catch (IOException e) {            throw new RuntimeException("Failed to load payments", e);        }    }}